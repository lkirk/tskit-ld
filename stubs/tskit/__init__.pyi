from pathlib import Path


class TreeSequence:
    def __init__(self, ll_tree_sequence) -> None: ...
    def __getstate__(self) -> TableCollection: ...
    def __setstate__(self, tc) -> None: ...
    def __eq__(self, other) -> bool: ...
    def equals(
        self,
        other,
        *,
        ignore_metadata=...,
        ignore_ts_metadata=...,
        ignore_provenance=...,
        ignore_timestamps=...,
        ignore_tables=...,
        ignore_reference_sequence=...
    ) -> bool: ...
    @property
    def ll_tree_sequence(self) -> Any: ...
    def get_ll_tree_sequence(self) -> Any: ...
    def aslist(self, **kwargs) -> list[Tree]: ...
    @classmethod
    def load(
        cls, file_or_path, *, skip_tables=..., skip_reference_sequence=...
    ) -> TreeSequence | None: ...
    @classmethod
    def load_tables(cls, tables, *, build_indexes=...) -> TreeSequence: ...
    def dump(self, file_or_path, zlib_compression=...) -> None: ...
    @property
    def reference_sequence(self) -> ReferenceSequence | None: ...
    def has_reference_sequence(self) -> bool: ...
    @property
    def tables_dict(self) -> Dict[Any, Any]: ...
    @property
    def tables(self) -> TableCollection: ...
    @property
    def nbytes(self) -> int: ...
    def dump_tables(self) -> TableCollection: ...
    def dump_text(
        self,
        nodes=...,
        edges=...,
        sites=...,
        mutations=...,
        individuals=...,
        populations=...,
        migrations=...,
        provenances=...,
        precision=...,
        encoding=...,
        base64_metadata=...,
    ) -> None: ...
    def __str__(self) -> str: ...
    @property
    def num_samples(self): ...
    @property
    def table_metadata_schemas(self) -> TableMetadataSchemas: ...
    @property
    def sample_size(self): ...
    def get_sample_size(self): ...
    @property
    def file_uuid(self): ...
    @property
    def discrete_genome(self) -> bool: ...
    @property
    def discrete_time(self) -> bool: ...
    @property
    def min_time(self): ...
    @property
    def max_time(self): ...
    @property
    def sequence_length(self): ...
    def get_sequence_length(self): ...
    @property
    def metadata(self) -> Any: ...
    @property
    def metadata_schema(self) -> metadata_module.MetadataSchema: ...
    @property
    def time_units(self) -> str: ...
    @property
    def num_edges(self): ...
    def get_num_trees(self): ...
    @property
    def num_trees(self): ...
    def get_num_sites(self): ...
    @property
    def num_sites(self): ...
    def get_num_mutations(self): ...
    @property
    def num_mutations(self): ...
    def get_num_nodes(self): ...
    @property
    def num_individuals(self): ...
    @property
    def num_nodes(self): ...
    @property
    def num_provenances(self): ...
    @property
    def num_populations(self): ...
    @property
    def num_migrations(self): ...
    @property
    def max_root_time(self): ...
    def migrations(self) -> SimpleContainerSequence: ...
    def individuals(self) -> SimpleContainerSequence: ...
    def nodes(self, *, order=...) -> SimpleContainerSequence: ...
    def edges(self) -> SimpleContainerSequence: ...
    def edgesets(self) -> Generator[Any, Any, None]: ...
    def edge_diffs(
        self, include_terminal=..., *, direction=...
    ) -> Generator[EdgeDiff, Any, None]: ...
    def sites(self) -> SimpleContainerSequence: ...
    def mutations(self) -> Generator[Any, Any, None]: ...
    def populations(self) -> SimpleContainerSequence: ...
    def provenances(self) -> SimpleContainerSequence: ...
    def breakpoints(self, as_array=...) -> map[float]: ...
    def at(self, position, **kwargs) -> Tree: ...
    def at_index(self, index, **kwargs) -> Tree: ...
    def first(self, **kwargs) -> Tree: ...
    def last(self, **kwargs) -> Tree: ...
    def trees(
        self,
        tracked_samples=...,
        *,
        sample_lists=...,
        root_threshold=...,
        sample_counts=...,
        tracked_leaves=...,
        leaf_counts=...,
        leaf_lists=...
    ) -> TreeIterator: ...
    def coiterate(
        self, other, **kwargs
    ) -> Generator[tuple[Interval, Tree | None, Any | None], Any, None]: ...
    def haplotypes(
        self,
        *,
        isolated_as_missing=...,
        missing_data_character=...,
        samples=...,
        left=...,
        right=...,
        impute_missing_data=...
    ) -> Generator[Any, Any, None]: ...
    def variants(
        self,
        *,
        samples=...,
        isolated_as_missing=...,
        alleles=...,
        impute_missing_data=...,
        copy=...,
        left=...,
        right=...
    ) -> Generator[Variant, Any, None]: ...
    def genotype_matrix(
        self,
        *,
        samples=...,
        isolated_as_missing=...,
        alleles=...,
        impute_missing_data=...
    ) -> NDArray[signedinteger[_32Bit]]: ...
    def alignments(
        self,
        *,
        reference_sequence=...,
        missing_data_character=...,
        samples=...,
        left=...,
        right=...
    ) -> Generator[Any, Any, None]: ...
    @property
    def individuals_population(self): ...
    @property
    def individual_populations(self): ...
    @property
    def individuals_time(self): ...
    @property
    def individual_times(self): ...
    @property
    def individuals_location(self) -> Any: ...
    @property
    def individual_locations(self) -> Any: ...
    @property
    def individuals_flags(self): ...
    @property
    def nodes_time(self): ...
    @property
    def nodes_flags(self): ...
    @property
    def nodes_population(self): ...
    @property
    def nodes_individual(self): ...
    @property
    def edges_left(self): ...
    @property
    def edges_right(self): ...
    @property
    def edges_parent(self): ...
    @property
    def edges_child(self): ...
    @property
    def sites_position(self): ...
    @property
    def mutations_site(self): ...
    @property
    def mutations_node(self): ...
    @property
    def mutations_parent(self): ...
    @property
    def mutations_time(self): ...
    @property
    def migrations_left(self): ...
    @property
    def migrations_right(self): ...
    @property
    def migrations_node(self): ...
    @property
    def migrations_source(self): ...
    @property
    def migrations_dest(self): ...
    @property
    def migrations_time(self): ...
    @property
    def indexes_edge_insertion_order(self): ...
    @property
    def indexes_edge_removal_order(self): ...
    def individual(self, id_) -> Any: ...
    def node(self, id_) -> Any: ...
    @staticmethod
    def check_index(index, length) -> Integral: ...
    def edge(self, id_) -> Any: ...
    def migration(self, id_) -> Any: ...
    def mutation(self, id_) -> Any: ...
    def site(self, id_=..., *, position=...) -> Any: ...
    def population(self, id_) -> Any: ...
    def provenance(self, id_) -> Provenance: ...
    def get_samples(self, population_id=...): ...
    def samples(self, population=..., *, population_id=..., time=...): ...
    def as_vcf(self, *args, **kwargs) -> str: ...
    def write_vcf(
        self,
        output,
        ploidy=...,
        *,
        contig_id=...,
        individuals=...,
        individual_names=...,
        position_transform=...,
        site_mask=...,
        sample_mask=...,
        isolated_as_missing=...,
        allow_position_zero=...
    ) -> None: ...
    def write_fasta(
        self,
        file_or_path,
        *,
        wrap_width=...,
        reference_sequence=...,
        missing_data_character=...
    ) -> None: ...
    def as_fasta(self, **kwargs) -> str: ...
    def write_nexus(
        self,
        file_or_path,
        *,
        precision=...,
        include_trees=...,
        include_alignments=...,
        reference_sequence=...,
        missing_data_character=...
    ) -> None: ...
    def as_nexus(self, **kwargs) -> str: ...
    def to_macs(self) -> str: ...
    def simplify(
        self,
        samples=...,
        *,
        map_nodes=...,
        reduce_to_site_topology=...,
        filter_populations=...,
        filter_individuals=...,
        filter_sites=...,
        filter_nodes=...,
        update_sample_flags=...,
        keep_unary=...,
        keep_unary_in_individuals=...,
        keep_input_roots=...,
        record_provenance=...,
        filter_zero_mutation_sites=...
    ) -> tuple[TreeSequence, Any] | TreeSequence: ...
    def delete_sites(self, site_ids, record_provenance=...) -> TreeSequence: ...
    def delete_intervals(
        self, intervals, simplify=..., record_provenance=...
    ) -> TreeSequence: ...
    def keep_intervals(
        self, intervals, simplify=..., record_provenance=...
    ) -> TreeSequence: ...
    def ltrim(self, record_provenance=...) -> TreeSequence: ...
    def rtrim(self, record_provenance=...) -> TreeSequence: ...
    def trim(self, record_provenance=...) -> TreeSequence: ...
    def split_edges(
        self, time, *, flags=..., population=..., metadata=...
    ) -> TreeSequence: ...
    def decapitate(
        self, time, *, flags=..., population=..., metadata=...
    ) -> TreeSequence: ...
    def extend_edges(self, max_iter=...) -> TreeSequence: ...
    def subset(
        self,
        nodes,
        record_provenance=...,
        reorder_populations=...,
        remove_unreferenced=...,
    ) -> TreeSequence: ...
    def union(
        self,
        other,
        node_mapping,
        check_shared_equality=...,
        add_populations=...,
        record_provenance=...,
    ) -> TreeSequence: ...
    def draw_svg(
        self,
        path=...,
        *,
        size=...,
        x_scale=...,
        time_scale=...,
        tree_height_scale=...,
        node_labels=...,
        mutation_labels=...,
        root_svg_attributes=...,
        style=...,
        order=...,
        force_root_branch=...,
        symbol_size=...,
        x_axis=...,
        x_label=...,
        x_lim=...,
        y_axis=...,
        y_label=...,
        y_ticks=...,
        y_gridlines=...,
        omit_sites=...,
        canvas_size=...,
        max_num_trees=...,
        **kwargs
    ) -> SVGString: ...
    def draw_text(
        self,
        *,
        node_labels=...,
        use_ascii=...,
        time_label_format=...,
        position_label_format=...,
        order=...,
        **kwargs
    ) -> str: ...
    def general_stat(
        self,
        W,
        f,
        output_dim,
        windows=...,
        polarised=...,
        mode=...,
        span_normalise=...,
        strict=...,
    ): ...
    def sample_count_stat(
        self,
        sample_sets,
        f,
        output_dim,
        windows=...,
        polarised=...,
        mode=...,
        span_normalise=...,
        strict=...,
    ): ...
    def parse_windows(self, windows) -> NDArray[Any]: ...
    def parse_sites(self, sites) -> tuple[Any | None, Any | None]: ...
    def parse_positions(self, positions) -> tuple[Any | None, Any | None]: ...
    def diversity(self, sample_sets=..., windows=..., mode=..., span_normalise=...): ...
    def divergence(
        self, sample_sets, indexes=..., windows=..., mode=..., span_normalise=...
    ): ...
    def divergence_matrix(
        self,
        sample_sets=...,
        *,
        windows=...,
        num_threads=...,
        mode=...,
        span_normalise=...
    ) -> Any | NDArray[Any] | int: ...
    def genetic_relatedness(
        self,
        sample_sets,
        indexes=...,
        windows=...,
        mode=...,
        span_normalise=...,
        polarised=...,
        proportion=...,
    ): ...
    def genetic_relatedness_matrix(
        self,
        sample_sets=...,
        *,
        windows=...,
        num_threads=...,
        mode=...,
        span_normalise=...
    ) -> Any | NDArray[Any] | int: ...
    def genetic_relatedness_weighted(
        self, W, indexes=..., windows=..., mode=..., span_normalise=..., polarised=...
    ): ...
    def trait_covariance(self, W, windows=..., mode=..., span_normalise=...): ...
    def trait_correlation(self, W, windows=..., mode=..., span_normalise=...): ...
    def trait_regression(self, *args, **kwargs): ...
    def trait_linear_model(
        self, W, Z=..., windows=..., mode=..., span_normalise=...
    ): ...
    def segregating_sites(
        self, sample_sets=..., windows=..., mode=..., span_normalise=...
    ): ...
    def allele_frequency_spectrum(
        self, sample_sets=..., windows=..., mode=..., span_normalise=..., polarised=...
    ): ...
    def Tajimas_D(self, sample_sets=..., windows=..., mode=...): ...
    def Fst(
        self, sample_sets, indexes=..., windows=..., mode=..., span_normalise=...
    ): ...
    def Y3(
        self, sample_sets, indexes=..., windows=..., mode=..., span_normalise=...
    ): ...
    def Y2(
        self, sample_sets, indexes=..., windows=..., mode=..., span_normalise=...
    ): ...
    def Y1(self, sample_sets, windows=..., mode=..., span_normalise=...): ...
    def f4(
        self, sample_sets, indexes=..., windows=..., mode=..., span_normalise=...
    ): ...
    def f3(
        self, sample_sets, indexes=..., windows=..., mode=..., span_normalise=...
    ): ...
    def f2(
        self, sample_sets, indexes=..., windows=..., mode=..., span_normalise=...
    ): ...
    def mean_descendants(self, sample_sets): ...
    def genealogical_nearest_neighbours(
        self, focal, sample_sets, num_threads=...
    ) -> NDArray[Any]: ...
    def kc_distance(self, other, lambda_=...): ...
    def count_topologies(
        self, sample_sets=...
    ) -> Generator[TopologyCounter, Any, None]: ...
    def ibd_segments(
        self,
        *,
        within=...,
        between=...,
        max_time=...,
        min_span=...,
        store_pairs=...,
        store_segments=...
    ) -> IdentitySegments: ...
    def pair_coalescence_counts(
        self,
        sample_sets=...,
        indexes=...,
        windows=...,
        span_normalise=...,
        time_windows=...,
    ): ...
    def impute_unknown_mutations_time(self, method=...) -> None: ...
    def ld_matrix(
        self, sample_sets=..., sites=..., positions=..., mode=..., stat=...
    ): ...
    def ld_matrix_two_way(
        self, sample_sets, indexes=..., sites=..., positions=..., mode=..., stat=...
    ): ...
    def ld_matrix_three_way(
        self, sample_sets, indexes=..., sites=..., positions=..., mode=..., stat=...
    ): ...
    def ld_matrix_four_way(
        self, sample_sets, indexes=..., sites=..., positions=..., mode=..., stat=...
    ): ...
    def get_pairwise_diversity(self, samples=...) -> float: ...
    def pairwise_diversity(self, samples=...) -> float: ...
    def get_time(self, u) -> Any: ...
    def get_population(self, u) -> Any: ...
    def records(self) -> Generator[CoalescenceRecord, Any, None]: ...
    def get_num_records(self): ...
    def diffs(self): ...
    def newick_trees(self, precision=..., breakpoints=..., Ne=...): ...
    def to_nexus(self, precision=...): ...

def load(
    file: Path | int,
    *,
    skip_tables: bool = False,
    skip_reference_sequence: bool = False
) -> TreeSequence: ...
